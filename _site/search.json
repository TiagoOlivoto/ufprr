[
  {
    "objectID": "00_about.html",
    "href": "00_about.html",
    "title": "Informações Úteis!",
    "section": "",
    "text": "Este material contém os scripts e dados necessários para reproduzir os exemplos vistos no minicurso Linguagem R aplicada à Engenharia Florestal\n\n\n1 Software\nPara reproduzir os exemplos deste material, você precisará do software R e RStudio (Português).\n\n Baixar R\n Baixar RStudio\n\n2 Instalação de pacotes\n\ninstall.packages(\"tidyverse\")\ninstall.packages(\"purrr\")\ninstall.packages(\"rio\")\ninstall.packages(\"DataExplorer\")\ninstall.packages(\"rnaturalearth\")\ninstall.packages(\"geobr\")\ninstall.packages(\"pak\")\n\nInstale também as versões de desenvolvimento de pliman e plimanshiny.\n\npak::pkg_install(\"NEPEM-UFSC/pliman\")\npak::pkg_install(\"NEPEM-UFSC/plimanshiny\")\n\nNota: Se você for usuário do Windows, é sugerido primeiro baixar e instalar a versão mais recente do Rtools. Para as notas de lançamento mais recentes desta versão em desenvolvimento, veja o arquivo de notícias.\n\n\n3 Scripts e orientações\nO arquivo .zip contém uma pasta com o site estático, estruturado da seguinte forma:\n\n\nD:/Desktop/UFSC/cursos/ufprr\n├── 00_about.qmd\n├── 00_about.rmarkdown\n├── 01_intro.qmd\n├── 01_programacao.qmd\n├── 02_dados.qmd\n├── 03_selecao.qmd\n├── 04_manipulacao.qmd\n├── 05_mutacao.qmd\n├── 06_resumo.qmd\n├── 07_datavis.qmd\n├── 08_pliman.qmd\n├── data\n│   ├── data.xlsx\n│   ├── df_excel.xlsx\n│   ├── df_messy.xlsx\n│   ├── eucalipto.xlsx\n│   ├── examples_data.xlsx\n│   ├── exportado.csv\n│   ├── exportado.txt\n│   ├── exportado.xlsx\n│   ├── joins.xlsx\n│   ├── pontos.png\n│   └── shapefile.rds\n├── figs\n│   ├── across.png\n│   ├── alcinei.jpg\n│   ├── autores_r.png\n│   ├── bem-vindo.png\n│   ├── book_olivoto.png\n│   ├── calendr.png\n│   ├── catarina.jpg\n│   ├── Console.png\n│   ├── data-transformation.pdf\n│   ├── datastructure.png\n│   ├── Diretory.png\n│   ├── eambr.png\n│   ├── env.png\n│   ├── esquisse.png\n│   ├── esquisse_import.png\n│   ├── feijao.png\n│   ├── Figura.png\n│   ├── Figura2.png\n│   ├── fill.png\n│   ├── filter.png\n│   ├── filter_join.png\n│   ├── giles.png\n│   ├── group_by.png\n│   ├── Help.png\n│   ├── Import.png\n│   ├── Import1.png\n│   ├── Import2.png\n│   ├── Install.png\n│   ├── logo.jpeg\n│   ├── mutate.png\n│   ├── mutate_join.png\n│   ├── olivoto.png\n│   ├── pipe.png\n│   ├── pivot_longer.png\n│   ├── pivot_wider.png\n│   ├── r4ds.png\n│   ├── rapidinhasdor.png\n│   ├── rqt.png\n│   ├── select.png\n│   ├── separate.png\n│   ├── summarize.png\n│   ├── tidy.png\n│   ├── unite.png\n│   ├── Update.png\n│   └── Valor_inicial.png\n├── pliman\n│   ├── E10_1457.jpg\n│   ├── E10_1487.jpg\n│   ├── E17_2335.jpg\n│   ├── E17_2336.jpg\n│   ├── E19_2475.jpg\n│   ├── E20_2490.jpg\n│   ├── E28_3300.jpg\n│   ├── E2_1101.jpg\n│   ├── E3_1597.jpg\n│   ├── E4_1133.jpg\n│   ├── E5_1200.jpg\n│   ├── E6_1310.jpg\n│   ├── E8_1397.jpg\n│   ├── folhas.jpg\n│   ├── G01.jpg\n│   ├── G02.jpg\n│   ├── G03.jpg\n│   ├── G04.jpg\n│   ├── G05.jpg\n│   ├── G06.jpg\n│   ├── G07.jpg\n│   ├── img_exported_tif.tif\n│   ├── orthomosaicos\n│   └── potato.jpg\n├── ufprr.Rproj\n├── _quarto.yml\n└── _site\n    ├── 00_about.html\n    ├── 01_intro.html\n    ├── 01_programacao.html\n    ├── 02_dados.html\n    ├── 03_selecao.html\n    ├── 04_manipulacao.html\n    ├── 05_mutacao.html\n    ├── 06_resumo.html\n    ├── 07_datavis.html\n    ├── 08_pliman.html\n    ├── figs\n    ├── index.html\n    ├── search.json\n    └── site_libs\n\n\nO material em HTML (_site/index.html) dará acesso ao site, onde você poderá ver todos os exemplos, com códigos e saídas. Para reproduzir o material, basta usar os arquivos *.qmd.\nPara a reprodução, sugere-se definir a pasta ufprr como o diretório padrão. Você pode facilmente definir o diretório executando o seguinte comando, assumindo que o script 00_about.qmd esteja aberto.\n\npliman::set_wd_here()\n\n\n4 Licença\nEste conteúdo está licenciado sob uma CC BY-NC-SA 4.0. O resumo legível da licença afirma que você tem o direito de:\n\n\nCompartilhar — copiar e redistribuir o material em qualquer meio ou formato.\n\nAdaptar — remixar, transformar e construir em cima do material.\n\nAtribuição — Você deve dar o crédito apropriado, fornecer um link para a licença e indicar se foram feitas alterações. Você pode fazê-lo de qualquer maneira razoável, mas não de forma que sugira que o licenciador apoia você ou seu uso.\nSob os seguintes termos:\nNão Comercial — Você não pode usar o material para fins comerciais.\nCompartilhamento pela mesma licença — Se você remixar, transformar ou construir em cima do material, você deve distribuir suas contribuições sob a mesma licença que o original.\nSem restrições adicionais — Você não pode aplicar termos legais ou medidas tecnológicas que restrinjam legalmente outros de fazerem qualquer coisa que a licença permita."
  },
  {
    "objectID": "08_pliman.html",
    "href": "08_pliman.html",
    "title": "pliman",
    "section": "",
    "text": "library(pliman)\nlibrary(tidyverse)\n\n# setwd(\"./imgs\")\n# set_wd_here(\"pliman\")\n\n\n\n\nimg &lt;- image_import(\"folhas.jpg\")\n\n\nImagens individuais são exibidas com plot(). Para combinar imagens, é usada a função image_combine(). Os usuários podem inserir uma lista separada por vírgulas de objetos ou uma lista de objetos da classe Image.\n\n# Imagens individuais\nplot(img)\n\n\n\n\n\nPara exportar imagens para o diretório atual, use a função image_export(). Se uma lista de imagens for exportada, as imagens serão salvas considerando o nome e a extensão presentes na lista. Se nenhuma extensão estiver presente, as imagens serão salvas como arquivos *.jpg.\n\nimage_export(img, \"img_exported_tif.tif\")"
  },
  {
    "objectID": "08_pliman.html#importar-e-exibir",
    "href": "08_pliman.html#importar-e-exibir",
    "title": "pliman",
    "section": "",
    "text": "img &lt;- image_import(\"folhas.jpg\")\n\n\nImagens individuais são exibidas com plot(). Para combinar imagens, é usada a função image_combine(). Os usuários podem inserir uma lista separada por vírgulas de objetos ou uma lista de objetos da classe Image.\n\n# Imagens individuais\nplot(img)"
  },
  {
    "objectID": "08_pliman.html#exportar",
    "href": "08_pliman.html#exportar",
    "title": "pliman",
    "section": "",
    "text": "Para exportar imagens para o diretório atual, use a função image_export(). Se uma lista de imagens for exportada, as imagens serão salvas considerando o nome e a extensão presentes na lista. Se nenhuma extensão estiver presente, as imagens serão salvas como arquivos *.jpg.\n\nimage_export(img, \"img_exported_tif.tif\")"
  },
  {
    "objectID": "08_pliman.html#índices-de-imagem",
    "href": "08_pliman.html#índices-de-imagem",
    "title": "pliman",
    "section": "\n2.1 Índices de imagem",
    "text": "2.1 Índices de imagem\nA função image_index() image_index() Constrói índices de imagens usando bandas Red, Green, Blue, Red-Edge e NIR.\n\n# Calcule os índices\nindexes &lt;- image_index(img, index = c(\"R, G, B, GRAY, B-G/(B+G)\"))\n\nIndex 'B-G/(B+G)' is not available. Trying to compute your own index.\n\n\n\n\n# Cria um histograma com os valores RGB\nplot(indexes, type = \"density\")\n\n\n\n\nNo caso do índice R, os dois picos representam a folha + a referência (pico menor) e o fundo (pico maior). Quanto mais clara for a diferença entre esses picos, melhor será a segmentação da imagem."
  },
  {
    "objectID": "08_pliman.html#imagens-binárias",
    "href": "08_pliman.html#imagens-binárias",
    "title": "pliman",
    "section": "\n2.2 Imagens binárias",
    "text": "2.2 Imagens binárias\nPara segmentar objetos, o pliman usa a técnica de threshold (Otsu, 1979)1, ou seja, um ponto de corte (considerando os valores dos pixels) é escolhido e a imagem é classificada em duas classes (primeiro plano e fundo). Em seguida, temos uma imagem binária. Podemos produzir essa imagem com image_binary(). Essa binarização é o processo-chave para todas as etapas de análise de objetos. Quanto melhor a binarização, melhores serão os resultados.\n\nimage_index(img, index = \"R\")\n\n\n\n#| out-width: \"100%\"\nimage_binary(img,  \n             # threshold = 0.5,\n             index = \"R\")"
  },
  {
    "objectID": "08_pliman.html#segmentação",
    "href": "08_pliman.html#segmentação",
    "title": "pliman",
    "section": "\n2.3 Segmentação",
    "text": "2.3 Segmentação\n\nimage_segment(img, \"R\")"
  },
  {
    "objectID": "08_pliman.html#análise-de-objetos",
    "href": "08_pliman.html#análise-de-objetos",
    "title": "pliman",
    "section": "\n2.4 Análise de objetos",
    "text": "2.4 Análise de objetos\nO segredo é obter o contorno dos objetos, assim, trabalhamos com polígonos!\n\nUm ‘polígono’ é uma figura plana descrita por um número finito de segmentos de linha reta conectados para formar uma cadeia poligonal fechada (Singer, 1993)2.\n\nPodemos então concluir que objetos de imagem podem ser expressos como polígonos com n vértices. O pliman possui uma família de funções poly_*() que podem ser usadas para analisar polígonos.\n\nsquare &lt;- draw_square() |&gt; poly_close()\n\n\n\npoly_area(square)\n\n[1] 4\n\npoly_perimeter(square)\n\n[1] 8\n\npolygon &lt;- draw_n_tagon(6)\npoly_area(polygon)\n\n[1] 2.598076\n\nn &lt;- c(6, 10, 100, 1000, 100000)\nsapply(n, function(x){\n  draw_n_tagon(x) |&gt; poly_area()\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n[1] 2.598076 2.938926 3.139526 3.141572 3.141593\n\n\n\n2.4.1 Contorno\n\n# extrair o contorno\ncont &lt;- object_contour(img, index = \"R\", watershed = FALSE)\n\n\n\n# Número de píxeis do contorno\nnrow(cont[[3]])\n\n[1] 1671\n\n# coordenadas do contorno\nhead(cont[[3]])\n\n     [,1] [,2]\n[1,] 2114  520\n[2,] 2113  521\n[3,] 2112  521\n[4,] 2111  522\n[5,] 2110  523\n[6,] 2109  523\n\n# polígono\nplot_polygon(cont[[3]])"
  },
  {
    "objectID": "08_pliman.html#medidas",
    "href": "08_pliman.html#medidas",
    "title": "pliman",
    "section": "\n2.5 Medidas",
    "text": "2.5 Medidas\nNa versão atual do pliman, você pode calcular as seguintes medidas. Para mais detalhes, ver Chen & Wang (2005)3, Claude (2008)4 e Montero et al. (2009)5."
  },
  {
    "objectID": "08_pliman.html#área",
    "href": "08_pliman.html#área",
    "title": "pliman",
    "section": "\n2.6 Área",
    "text": "2.6 Área\nA área de uma forma é calculada usando a fórmula de Shoelace (Lee e Lim, 2017)6, como segue\n\\[\nA=\\frac{1}{2}\\left |\\sum_{i=1}^{n}\\left(x_{i} y_{i+1}-x_{i+1}y_{i}\\right)\\right|\n\\]\n\npoly_area(cont)\n\n[1] 289016.5 471305.0  98843.5 222263.0"
  },
  {
    "objectID": "08_pliman.html#perímetro",
    "href": "08_pliman.html#perímetro",
    "title": "pliman",
    "section": "\n2.7 Perímetro",
    "text": "2.7 Perímetro\nO perímetro é calculado como a soma da distância euclidiana entre todos os pontos de uma forma. As distâncias podem ser obtidas com poly_distpts().\n\npoly_perimeter(cont)\n\n       1        5        7       21 \n6619.296 2675.806 2015.040 3201.973 \n\n#perímetro de um círculo com raio 2\ncirculo &lt;- draw_circle(radius = 2, plot = FALSE)\npoly_perimeter(circulo)\n\n[1] 12.56635\n\n#verifique o resultado\n2*pi*2\n\n[1] 12.56637"
  },
  {
    "objectID": "08_pliman.html#centro-de-massa",
    "href": "08_pliman.html#centro-de-massa",
    "title": "pliman",
    "section": "\n2.8 Centro de massa",
    "text": "2.8 Centro de massa\nO centro de massa de uma forma, especialmente no espaço bidimensional, representa a posição média de todos os pontos dentro dessa forma, ponderados por sua área (ou massa, se considerarmos objetos físicos). É o ponto em que toda a área (ou massa) da forma pode ser considerada concentrada. Em termos práticos, se você fosse equilibrar um recorte da forma em um ponto específico, o centro de massa seria o local onde ele se equilibraria perfeitamente.\nEm um polígono (uma forma feita de segmentos de linha reta), o centro de massa é calculado considerando a contribuição de cada segmento para a forma geral, e suas coordenadas (\\(C_x\\) e \\(C_y\\)) são dadas por\n\\[\n\\begin{aligned}\nC_x & =\\frac{1}{6 A} \\sum_{i=1}^n\\left(x_i+x_{i+1}\\right)\\left(x_i y_{i+1}-x_{i+1} y_i\\right) \\\\\nC_y & =\\frac{1}{6 A} \\sum_{i=1}^n\\left(y_i+y_{i+1}\\right)\\left(x_i y_{i+1}-x_{i+1} y_i\\right)\n\\end{aligned}\n\\] Onde A, é a área dada acima\n\nplot_polygon(cont[[4]])\n\n# centroid\ncent &lt;- apply(cont[[4]], 2, mean)\npoints(cent[1], cent[2], col = \"red\", pch = 19)  # Red dot for centroid\n\n# Center of mass\ncm &lt;- poly_mass(cont[[4]])\npoints(cm[1], cm[2], col = \"blue\", pch = 19)  # Blue dot for center of mass\nlegend(\"topright\",\n       legend = c(\"Centróide\", \"Centro de massa\"), \n       col = c(\"red\", \"blue\"), pch = 19)\n\n\n\n\n\ndist &lt;- poly_centdist_mass(cont[[4]])\nx &lt;- c(cm[1], cont[[4]][1, 1])\ny &lt;- c(cm[2], cont[[4]][1, 2])\nd1 &lt;- sqrt(diff(x)^2 + diff(y)^2)\ndist[[1]]\n\n[1] 522.509\n\nplot_polygon(cont[[4]])\npoints(cm[1], cm[2], col = \"blue\", pch = 19)  # Blue dot for center of mass\nsegments(x[1], y[1], x[2], y[2], col = \"blue\", lwd = 2)\n\n\n\nplot(dist, type = \"l\")"
  },
  {
    "objectID": "08_pliman.html#comprimento-e-largura",
    "href": "08_pliman.html#comprimento-e-largura",
    "title": "pliman",
    "section": "\n2.9 Comprimento e largura",
    "text": "2.9 Comprimento e largura\nO comprimento e a largura de um objeto são calculados com poly_lw(), como a diferença entre o máximo e o mínimo das coordenadas x e y após o objeto ter sido alinhado com poly_align().\n\n# wrong measures\nplot_polygon(cont[[4]])\nlw &lt;- apply(cont[[4]], 2, \\(x){range(x)})\nabline(v = lw[[1]], col = \"red\")\nabline(v = lw[[2]], col = \"red\")\nabline(h = lw[[3]], col = \"blue\")\nabline(h = lw[[4]], col = \"blue\")\n\n\n\n# Correct measures\naligned &lt;- poly_align(cont[[4]])\nlw &lt;- apply(aligned, 2, \\(x){range(x)})\nabline(v = lw[[1]], col = \"red\")\nabline(v = lw[[2]], col = \"red\")\nabline(h = lw[[3]], col = \"blue\")\nabline(h = lw[[4]], col = \"blue\")\n\n\n\ndiff(lw)\n\n         [,1]     [,2]\n[1,] 404.7655 893.0728\n\n# with poly_lw()\npoly_lw(cont[[4]])\n\n       length    width\n[1,] 893.0728 404.7655"
  },
  {
    "objectID": "08_pliman.html#complexidade-do-perímetro-pvc",
    "href": "08_pliman.html#complexidade-do-perímetro-pvc",
    "title": "pliman",
    "section": "\n2.10 Complexidade do perímetro (PVC)",
    "text": "2.10 Complexidade do perímetro (PVC)\nO PCV é calculado primeiro suavizando o contorno de entrada usando um número especificado de iterações. O contorno suavizado é então usado para calcular as distâncias entre os pontos correspondentes nas coordenadas original e suavizada. Estas distâncias refletem as variações na forma do contorno após a suavização. A soma dessas distâncias representa a magnitude global das variações. A seguir, a soma das distâncias é multiplicada pelo desvio padrão das distâncias para capturar a dispersão ou propagação das variações.\nFinalmente, este valor é dividido pelo comprimento do perímetro do contorno original para fornecer uma medida relativa de complexidade. Portanto, o PCV fornece uma medida relativa de complexidade, considerando tanto a magnitude quanto a dispersão das variações na forma do contorno após a suavização.\n\nset.seed(1)\nplot_polygon(cont)\n\n\n\npoly_pcv(cont)\n\n        1         5         7        21 \n2.4546770 0.1792651 1.1181022 3.4462196"
  },
  {
    "objectID": "08_pliman.html#shapefile",
    "href": "08_pliman.html#shapefile",
    "title": "pliman",
    "section": "\n5.1 Shapefile",
    "text": "5.1 Shapefile\n\n5.1.1 Criar\nPara criar uma grade shapefile sobre o mosaico, a função shapefile_build() é usada, especificando o número de linhas e colunas para a grade. Isso permite a segmentação do mosaico em parcelas que podem ser analisadas individualmente.\n\n# Criar uma grade shapefile sobre o mosaico com linhas e colunas especificadas\nshp &lt;- shapefile_build(mosaic,\n                       ncol = 4, # Número de colunas\n                       nrow = 10) # Número de linhas\n\n\n5.1.2 Importar e Exportar\nOs shapefiles podem ser importados usando a função shapefile_input(), que lê objetos shapefile de um arquivo. Após a importação do shapefile, o mosaico pode ser plotado em RGB usando mosaic_plot_rgb(), e o shapefile pode ser sobreposto ao mosaico usando a função shapefile_plot(), que permite a personalização da largura da linha e outros parâmetros gráficos.\n\n# Importar um objeto shapefile de um arquivo\nshp &lt;- shapefile_input(\"orthomosaicos/shp_dsm.rds\")\n\n class       : SpatVector \n geometry    : polygons \n dimensions  : 486, 5  (geometries, attributes)\n extent      : 734323.3, 734358.8, 4488937, 4488979  (xmin, xmax, ymin, ymax)\n coord. ref. : WGS 72BE / UTM zone 14N (EPSG:32414) \n names       : unique_id block plot_id   row column\n type        :     &lt;int&gt; &lt;chr&gt;   &lt;chr&gt; &lt;int&gt;  &lt;int&gt;\n values      :         1   B01   P0001     1      1\n                       2   B01   P0018     2      1\n                       3   B01   P0019     3      1\n\n# Plotar o mosaico em RGB\nmosaic_plot_rgb(mosaic)\n\n# Sobrepor o shapefile importado ao mosaico com largura de linha personalizada\nshapefile_plot(shp, add = TRUE, lwd = 2)"
  },
  {
    "objectID": "08_pliman.html#índices-de-vegetação",
    "href": "08_pliman.html#índices-de-vegetação",
    "title": "pliman",
    "section": "\n5.2 Índices de Vegetação",
    "text": "5.2 Índices de Vegetação\nUma variedade de índices de vegetação estão disponíveis no pliman, como detalhado no site de Tiago Olivoto. Esses índices podem ser calculados usando a função mosaic_index(). Especificando os canais RGB do mosaico (por exemplo, R = 1, G = 2, B = 3) e selecionando os índices desejados (por exemplo, “NGRDI” e “GLI”), a função calcula os índices, que podem ser usados para análises posteriores.\n\n# Calcular índices de vegetação (por exemplo, NGRDI e GLI) usando os canais RGB do mosaico\nind &lt;- mosaic_index(mosaic, \n                    r = 1, # Canal vermelho\n                    g = 2, # Canal verde\n                    b = 3, # Canal azul\n                    index = c(\"NGRDI\", \"GLI\")) # Lista de índices de vegetação a calcular"
  },
  {
    "objectID": "08_pliman.html#extrair-índices-de-vegetação-para-cada-parcela",
    "href": "08_pliman.html#extrair-índices-de-vegetação-para-cada-parcela",
    "title": "pliman",
    "section": "\n5.3 Extrair Índices de Vegetação para Cada Parcela",
    "text": "5.3 Extrair Índices de Vegetação para Cada Parcela\nOs valores dos índices de vegetação podem ser extraídos para cada parcela definida por um shapefile usando a função mosaic_extract(). Esta função resume os valores dos índices de vegetação para cada parcela usando uma estatística de resumo especificada, como a mediana. Os resultados fornecem uma avaliação quantitativa das características de vegetação para cada parcela no mosaico.\n\n# Extrair valores de índices de vegetação para cada parcela no shapefile\n# Usando o valor mediano como estatística de resumo\nvals &lt;- \n  mosaic_extract(ind,\n                 shapefile = shp,\n                 fun = \"median\", # Função de resumo (por exemplo, mediana)\n                 progress = FALSE) # Desativar barra de progresso\n\n# Note que os valores são medianos para a parcela inteira\nhead(vals)\n\n  median.NGRDI    median.GLI\n1  -0.02875520 -0.0043149017\n2  -0.03219482 -0.0056097776\n3  -0.02834213 -0.0026563521\n4  -0.01880019  0.0056190410\n5  -0.02154014 -0.0002409597\n6  -0.02734165 -0.0035897693"
  },
  {
    "objectID": "08_pliman.html#a-função-mosaic_analyze",
    "href": "08_pliman.html#a-função-mosaic_analyze",
    "title": "pliman",
    "section": "\n5.4 A Função mosaic_analyze()\n",
    "text": "5.4 A Função mosaic_analyze()\n\nA função mosaic_analyze() realiza uma análise abrangente do mosaico usando o shapefile definido e os índices de vegetação selecionados. Ela integra várias etapas, incluindo o cálculo de índices de vegetação para cada parcela, o resumo dos resultados usando estatísticas especificadas (por exemplo, mediana, média), e opcionalmente segmentando parcelas para mascarar áreas não vegetadas, como solo. A função também pode criar mapas que exibem a distribuição espacial de um atributo escolhido, como um índice de vegetação, usando uma escala de cores.\n\n# Analisar o mosaico usando o shapefile definido e índices de vegetação\nres &lt;- \n  mosaic_analyze(mosaic,\n                 basemap = bm,                      # Mapa base para visualização\n                 shapefile = shp,                   # Shapefile com parcelas\n                 plot_index = c(\"NGRDI\", \"GLI\"),    # Índices de vegetação a calcular\n                 summarize_fun = c(\"median\", \"mean\"), # Estatísticas de resumo para cada parcela\n                 segment_plot = TRUE,               # Habilitar segmentação de parcela (por exemplo, mascarar solo)\n                 attribute = \"median.NGRDI\")        # Atributo para mapeamento (por exemplo, escala de cores NGRDI)\n\n\nBuilding the mosaic...\n\n\n\nComputing the indexes...\n\n\n\nExtracting data from block 1\n\n\n\nPreparing to plot...\n\n\nDone!\n\n# Exibir o gráfico de resultado\nres$result_plot\n\nSimple feature collection with 486 features and 12 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 734323.3 ymin: 4488937 xmax: 734358.8 ymax: 4488979\nProjected CRS: WGS 72BE / UTM zone 14N\nFirst 10 features:\n   unique_id block plot_id row column covered_area plot_area  coverage\n1          1   B01   P0001   1      1    0.7642349  2.900237 0.2635078\n2          2   B01   P0018   2      1    0.6449918  2.900237 0.2223928\n3          3   B01   P0019   3      1    0.8363436  2.900237 0.2883708\n4          4   B01   P0036   4      1    0.9164109  2.900237 0.3159779\n5          5   B01   P0037   5      1    0.8578147  2.900237 0.2957740\n6          6   B01   P0054   6      1    0.7955407  2.900237 0.2743019\n7          7   B01   P0055   7      1    0.6984577  2.900237 0.2408278\n8          8   B01   P0072   8      1    0.6917745  2.900237 0.2385234\n9          9   B01   P0073   9      1    0.7662282  2.900237 0.2641950\n10        10   B01   P0090  10      1    0.7393780  2.900237 0.2549371\n   median.NGRDI median.GLI mean.NGRDI  mean.GLI                       geometry\n1     0.3967721  0.3115136  0.4248079 0.3302597 POLYGON ((734323.3 4488978,...\n2     0.3747542  0.2883227  0.4120097 0.3120503 POLYGON ((734323.3 4488977,...\n3     0.3926369  0.3129989  0.4285467 0.3397390 POLYGON ((734323.3 4488977,...\n4     0.3769128  0.3011482  0.4163306 0.3298692 POLYGON ((734323.3 4488976,...\n5     0.3775156  0.2959503  0.4136510 0.3196619 POLYGON ((734323.4 4488975,...\n6     0.3796265  0.2924798  0.4172704 0.3185496 POLYGON ((734323.4 4488974,...\n7     0.4410714  0.3144464  0.4773394 0.3367778 POLYGON ((734323.4 4488974,...\n8     0.4538747  0.3289653  0.4806117 0.3421578 POLYGON ((734323.4 4488973,...\n9     0.4313277  0.3123756  0.4663233 0.3342863 POLYGON ((734323.5 4488972,...\n10    0.4326757  0.3183919  0.4658800 0.3392910 POLYGON ((734323.5 4488971,...\n\n\n\n5.4.1 Índice de Vegetação\nOs resultados da função mosaic_analyze() incluem um mapa que visualiza os índices de vegetação calculados, permitindo uma fácil interpretação dos padrões espaciais dentro do mosaico.\n\n# Exibir o mapa com índices de vegetação\nres$map_plot\n\n\n\n\n\n\n\n5.4.2 Cobertura de Dossel\nAs informações de cobertura de dossel podem ser visualizadas no mapa interativo adicionando o atributo de cobertura dos resultados da análise. Isso fornece uma representação visual da extensão e distribuição da cobertura do dossel dentro da área de estudo, aprimorando a compreensão da dinâmica da vegetação através do mosaico.\n\n# Adicionar atributo de cobertura de dossel ao mapa interativo\nbm + shapefile_view(res$result_plot, attribute = \"coverage\")"
  },
  {
    "objectID": "08_pliman.html#modelos-digitais-de-superfície-e-terreno",
    "href": "08_pliman.html#modelos-digitais-de-superfície-e-terreno",
    "title": "pliman",
    "section": "\n5.5 Modelos Digitais de Superfície e Terreno",
    "text": "5.5 Modelos Digitais de Superfície e Terreno\nPara calcular a altura das plantas usando Modelos Digitais de Superfície (DSM) e Modelos Digitais de Terreno (DTM), siga estas etapas. O DSM representa a elevação das superfícies superiores de objetos, incluindo vegetação, edifícios e outras estruturas, enquanto o DTM representa a superfície do solo nu sem quaisquer objetos. A altura das plantas pode ser calculada subtraindo o DTM do DSM, o que fornece a altura da vegetação acima do solo.\n\ndsm &lt;- mosaic_input(\"orthomosaicos/dsm_soy.tif\")\n\nclass       : SpatRaster \ndimensions  : 1993, 2011, 1  (nrow, ncol, nlyr)\nresolution  : 0.0216565, 0.0216565  (x, y)\nextent      : 734319.4, 734362.9, 4488937, 4488980  (xmin, xmax, ymin, ymax)\ncoord. ref. : WGS 72BE / UTM zone 14N (EPSG:32414) \nsource      : dsm_soy.tif \nname        :      dsm \nmin value   : 301.6189 \nmax value   : 303.2053 \n\nmosaic_plot(dsm)\n\n\n\ndtm &lt;- mosaic_input(\"orthomosaicos/dtm_soy.tif\")\n\nclass       : SpatRaster \ndimensions  : 1993, 2011, 1  (nrow, ncol, nlyr)\nresolution  : 0.0216565, 0.0216565  (x, y)\nextent      : 734319.4, 734362.9, 4488937, 4488980  (xmin, xmax, ymin, ymax)\ncoord. ref. : WGS 72BE / UTM zone 14N (EPSG:32414) \nsource      : dtm_soy.tif \nname        :      dtm \nmin value   : 301.6189 \nmax value   : 302.5974 \n\nmosaic_plot(dtm)\n\n\n\nmask &lt;- mosaic_input(\"orthomosaicos/mask_dsm_soy.tif\")\n\nclass       : SpatRaster \ndimensions  : 1993, 2011, 1  (nrow, ncol, nlyr)\nresolution  : 0.0216565, 0.0216565  (x, y)\nextent      : 734319.4, 734362.9, 4488937, 4488980  (xmin, xmax, ymin, ymax)\ncoord. ref. : WGS 72BE / UTM zone 14N (EPSG:32414) \nsource      : mask_dsm_soy.tif \nname        : NGRDI \nmin value   :     0 \nmax value   :     1 \n\nmosaic_plot(mask)"
  },
  {
    "objectID": "08_pliman.html#modelo-de-altura-de-dossel",
    "href": "08_pliman.html#modelo-de-altura-de-dossel",
    "title": "pliman",
    "section": "\n5.6 Modelo de Altura de Dossel",
    "text": "5.6 Modelo de Altura de Dossel\n\nchm &lt;- mosaic_chm(dsm = dsm, \n                  dtm = dtm,\n                  mask = mask,\n                  mask_soil = FALSE)\n\n\nBuilding the digital terrain model...\n\n\n\nDone!\n\nmosaic_plot(chm$chm)\n\n\n\n# extrair os valores\nph &lt;- mosaic_chm_extract(chm, shp)\nph\n\nSimple feature collection with 486 features and 20 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 734323.3 ymin: 4488937 xmax: 734358.8 ymax: 4488979\nProjected CRS: WGS 72BE / UTM zone 14N\nFirst 10 features:\n   unique_id block plot_id row column        x       y        min        q10\n1          1   B01   P0001   1      1 734325.2 4488978 0.05505371 0.16475220\n2          2   B01   P0018   2      1 734325.2 4488977 0.06753540 0.16409302\n3          3   B01   P0019   3      1 734325.2 4488976 0.03213501 0.14340820\n4          4   B01   P0036   4      1 734325.3 4488976 0.01007080 0.07337646\n5          5   B01   P0037   5      1 734325.3 4488975 0.01718140 0.11104126\n6          6   B01   P0054   6      1 734325.3 4488974 0.02648926 0.11910400\n7          7   B01   P0055   7      1 734325.3 4488973 0.05014038 0.14735107\n8          8   B01   P0072   8      1 734325.4 4488972 0.03253174 0.13973999\n9          9   B01   P0073   9      1 734325.4 4488972 0.04232788 0.12273560\n10        10   B01   P0090  10      1 734325.4 4488971 0.05572510 0.14743042\n         q50       q90        iqr      mean       max        cv  entropy\n1  0.2859497 0.3494202 0.08051300 0.2705834 0.3853149 0.2549856 3.208816\n2  0.2692261 0.3109131 0.07192993 0.2529030 0.3387451 0.2281215 2.966924\n3  0.2835999 0.3249084 0.07946777 0.2614269 0.3676758 0.2643031 3.100243\n4  0.2897949 0.3425812 0.10590363 0.2540826 0.3795166 0.3742137 3.290437\n5  0.2725220 0.3281372 0.10449219 0.2481975 0.4020081 0.3176949 3.220920\n6  0.2731934 0.3229553 0.08505249 0.2510921 0.3525085 0.2972484 3.153871\n7  0.2847443 0.3310852 0.08124542 0.2626665 0.3524780 0.2646583 3.060097\n8  0.2767334 0.3391724 0.09986877 0.2566287 0.3624573 0.2922186 3.236484\n9  0.3088074 0.3648560 0.11155701 0.2756882 0.3845520 0.3206748 3.267232\n10 0.2982178 0.3325745 0.07748413 0.2703736 0.3651733 0.2574367 3.021049\n      volume covered_area plot_area  coverage                       geometry\n1  0.2741141    1.0130486  2.900237 0.3492986 POLYGON ((734323.3 4488978,...\n2  0.2188401    0.8653124  2.900237 0.2983592 POLYGON ((734323.3 4488977,...\n3  0.2691295    1.0294638  2.900237 0.3549585 POLYGON ((734323.3 4488977,...\n4  0.3001290    1.1788623  2.900237 0.4064710 POLYGON ((734323.3 4488976,...\n5  0.2686883    1.0812679  2.900237 0.3728205 POLYGON ((734323.4 4488975,...\n6  0.2582547    1.0285258  2.900237 0.3546351 POLYGON ((734323.4 4488974,...\n7  0.2168173    0.8254470  2.900237 0.2846136 POLYGON ((734323.4 4488974,...\n8  0.2102687    0.8193500  2.900237 0.2825114 POLYGON ((734323.4 4488973,...\n9  0.2486417    0.9018947  2.900237 0.3109727 POLYGON ((734323.5 4488972,...\n10 0.2451166    0.9065847  2.900237 0.3125899 POLYGON ((734323.5 4488971,...\n\n# altura da planta \nbm + shapefile_view(ph, attribute = \"q90\")"
  },
  {
    "objectID": "08_pliman.html#um-exemplo-florestal",
    "href": "08_pliman.html#um-exemplo-florestal",
    "title": "pliman",
    "section": "\n5.7 Um exemplo florestal",
    "text": "5.7 Um exemplo florestal\n\nmosaic &lt;- mosaic_input(\"orthomosaicos/trees.tif\")\n\nclass       : SpatRaster \ndimensions  : 2596, 2146, 5  (nrow, ncol, nlyr)\nresolution  : 0.06, 0.06  (x, y)\nextent      : 475198.4, 475327.1, 5047562, 5047718  (xmin, xmax, ymin, ymax)\ncoord. ref. : WGS 84 / UTM zone 10N (EPSG:32610) \nsource      : trees.tif \nnames       : trees_1, trees_2, trees_3, trees_4, trees_5 \nmin values  :       0,       0,       0,       0,       0 \nmax values  :   13621,   18169,   20405,   22561,   28545 \n\nshp &lt;- shapefile_input(\"orthomosaicos/shape_trees.rds\")\n\n class       : SpatVector \n geometry    : polygons \n dimensions  : 2, 5  (geometries, attributes)\n extent      : 475198.4, 475325.7, 5047563, 5047718  (xmin, xmax, ymin, ymax)\n coord. ref. : WGS 84 / UTM zone 10N (EPSG:32610) \n names       : unique_id block plot_id   row column\n type        :     &lt;int&gt; &lt;chr&gt;   &lt;chr&gt; &lt;num&gt;  &lt;num&gt;\n values      :         1   B01   P0001     1      1\n                       2   B02   P0001     1      1\n\nbm &lt;- mosaic_view(mosaic,\n                  r = 3,\n                  g = 2,\n                  b = 1,\n                  max_pixels = 4e6)\n\nThe number of pixels is too high, which might slow the rendering process.\n\ninventario &lt;- \n  mosaic_analyze(mosaic,\n                 r = 3,\n                 nir = 5,\n                 shapefile = shp,\n                 basemap = bm,\n                 plot_index = \"NDVI\",\n                 threshold = 0.7,\n                 opening = 7,\n                 filter = 3,\n                 segment_individuals = TRUE)\n\n\nBuilding the mosaic...\n\n\nWarning in validate_and_replicate(segment_plot, created_shapes): `segment_plot`\nmust have length 1 or 2 (the number of drawn polygons).\n\n\nWarning in validate_and_replicate(segment_individuals, created_shapes):\n`segment_individuals` must have length 1 or 2 (the number of drawn polygons).\n\n\nWarning in validate_and_replicate(threshold, created_shapes): `threshold` must\nhave length 1 or 2 (the number of drawn polygons).\n\n\nWarning in validate_and_replicate(watershed, created_shapes): `watershed` must\nhave length 1 or 2 (the number of drawn polygons).\n\n\nWarning in validate_and_replicate(segment_index, created_shapes):\n`segment_index` must have length 1 or 2 (the number of drawn polygons).\n\n\nWarning in validate_and_replicate(invert, created_shapes): `invert` must have\nlength 1 or 2 (the number of drawn polygons).\n\n\nWarning in validate_and_replicate(includeopt, created_shapes): `includeopt`\nmust have length 1 or 2 (the number of drawn polygons).\n\n\nWarning in validate_and_replicate(opening, created_shapes): `opening` must have\nlength 1 or 2 (the number of drawn polygons).\n\n\nWarning in validate_and_replicate(closing, created_shapes): `closing` must have\nlength 1 or 2 (the number of drawn polygons).\n\n\nWarning in validate_and_replicate(filter, created_shapes): `filter` must have\nlength 1 or 2 (the number of drawn polygons).\n\n\nWarning in validate_and_replicate(erode, created_shapes): `erode` must have\nlength 1 or 2 (the number of drawn polygons).\n\n\nWarning in validate_and_replicate(dilate, created_shapes): `dilate` must have\nlength 1 or 2 (the number of drawn polygons).\n\n\nWarning in validate_and_replicate(grid, created_shapes): `grid` must have\nlength 1 or 2 (the number of drawn polygons).\n\n\nWarning in validate_and_replicate(lower_noise, created_shapes): `lower_noise`\nmust have length 1 or 2 (the number of drawn polygons).\n\n\n\nComputing the indexes...\n\n\n\nExtracting data from block 1\n\n\n\nExtracting data from block 2\n\n\n\nPreparing to plot...\n\n\nDone!\n\ninventario$map_indiv"
  },
  {
    "objectID": "07_datavis.html#o-pacote-ggplot2",
    "href": "07_datavis.html#o-pacote-ggplot2",
    "title": "8. Visualização de dados",
    "section": "\n3.1 O pacote ggplot2\n",
    "text": "3.1 O pacote ggplot2\n\nO ggplot2 é um pacote R para produção de gráficos que diferentemente da maioria dos outros pacotes, apresenta uma profunda gramática baseada no livro The grammar of graphics (Wilkinson 2005)1. Os gráficos originados em ggplot2 são baseados em camadas, e cada gráfico tem três componentes chave: data, os dados de onde o gráfico será criado; aes() (aesthetic mappings), que controla o mapeamento estético e as propriedades visuais do gráfico; e ao menos uma camada que irá descrever como cada observação será renderizada. Camadas são usualmente criadas utilizando uma função geom_()."
  },
  {
    "objectID": "07_datavis.html#galerias",
    "href": "07_datavis.html#galerias",
    "title": "8. Visualização de dados",
    "section": "\n3.2 Galerias",
    "text": "3.2 Galerias\n\nhttps://www.r-graph-gallery.com/portfolio/ggplot2-package/\nhttp://r-statistics.co/Top50-Ggplot2-Visualizations-MasterList-R-Code.html\nhttps://r4stats.com/examples/graphics-ggplot2/\nhttp://girke.bioinformatics.ucr.edu/GEN242/pages/mydoc/Rgraphics.html"
  },
  {
    "objectID": "07_datavis.html#extensões-do-ggplot2",
    "href": "07_datavis.html#extensões-do-ggplot2",
    "title": "8. Visualização de dados",
    "section": "\n3.3 Extensões do ggplot2\n",
    "text": "3.3 Extensões do ggplot2\n\n\nhttp://www.ggplot2-exts.org/gallery/\nhttps://mode.com/blog/r-ggplot-extension-packages"
  },
  {
    "objectID": "07_datavis.html#tutoriais-em-português",
    "href": "07_datavis.html#tutoriais-em-português",
    "title": "8. Visualização de dados",
    "section": "\n3.4 Tutoriais em português",
    "text": "3.4 Tutoriais em português\n\nhttps://rpubs.com/mnunes/ggplot2\nhttps://analisereal.com/2015/09/19/introducao-ao-ggplot2/\nhttps://timogrossenbacher.ch/2016/12/beautiful-thematic-maps-with-ggplot2-only/\nhttp://recologia.com.br/tag/graficos/\nhttp://rstudio-pubs-static.s3.amazonaws.com/24563_3b7b0a6414824e3b91769a95309380f1.html\nhttp://eduardogutierres.com/inteligencia-geografica-gerando-mapas-em-r/\nhttps://pt.stackoverflow.com/questions/332053/r-mapa-de-cidades-brasileiras"
  },
  {
    "objectID": "07_datavis.html#meu-primeiro-gráfico-em-ggplot2",
    "href": "07_datavis.html#meu-primeiro-gráfico-em-ggplot2",
    "title": "8. Visualização de dados",
    "section": "\n3.5 Meu primeiro gráfico em ggplot2\n",
    "text": "3.5 Meu primeiro gráfico em ggplot2\n\nA seguir, vamos discutir os aspcetos básicos para a construção de gráficos utilizando o pacote ggplot2. A função arrange_ggplot() do pacote metan é utilizada aqui para organizar os gráficos em forma de painéis."
  },
  {
    "objectID": "07_datavis.html#as-camadas-de-um-gráfico-ggplot2",
    "href": "07_datavis.html#as-camadas-de-um-gráfico-ggplot2",
    "title": "8. Visualização de dados",
    "section": "\n3.6 As camadas de um gráfico ggplot2\n",
    "text": "3.6 As camadas de um gráfico ggplot2\n\nNo ggplot2, os gráficos são construídos camada por camada (ou, layers, em inglês). Neste exemplo, vamos confeccionar um gráfico mostrando a distribuição do dap_suta da folha (eixo x) e circunferencia da folha (eixo y).\n\np1 &lt;- \n  ggplot(df, aes(x = dap_suta, y = circunferencia)) +\n  geom_point()\np1\n\n\n\n\nEste comando criou um gráfico e armazenou no objeto p1, que será plotado posteriormente. Observe que o primeiro argumento da função é o data frame onde nossos dados foram armazenados. A função aes() descreve como as variáveis são mapeadas (neste caso dap_suta no eixo x e circunferencia no eixo y). A função geom_point() definiu que a forma geométrica a ser utilizada é baseada em pontos, gerando, assim, um gráfico de dispersão. Isto é tudo que precisa ser feito para a confecção de um gráfico simples."
  },
  {
    "objectID": "07_datavis.html#aesthetics-estética",
    "href": "07_datavis.html#aesthetics-estética",
    "title": "8. Visualização de dados",
    "section": "\n3.7 Aesthetics (estética)",
    "text": "3.7 Aesthetics (estética)\n\n“O maior valor de uma imagem é quando ela nos obriga a perceber o que nunca esperamos ver.” — John Tukey\n\nAlterar a estética dos gráficos ggplot2 é uma tarefa relativamente simples. No gráfico anterior, os valores do dap_suta e circunferencia foram plotados sem nenhum tipo de mapeamento estético. Digamos que marcadores com diferentes cores para cada nível do fator fila poderia nos ajudar a compreender melhor o padrão presente em nossos dados. Vamos confeccionar este gráfico.\n\np2 &lt;- \n  ggplot(df, aes(x = dap_suta, y = circunferencia, color = fila)) +\n  geom_point()\np2\n\n\n\n\nAo incluirmos color = fila dentro da função aes, dizemos ao ggplot que os pontos devem ser mapeados esteticamente (neste caso utilizando cores) para cada nível do fator fila presente em nossos dados. Digamos que em vez de utilizar diferentes cores, cada fila deveria ser representada por diferentes tipos de marcadores (quadrados, triângulo, etc.) Neste caso, o argumento colour = fila é substituído por shape = fila.\n\np3 &lt;- \n  ggplot(df, aes(x = dap_suta, \n                 y = circunferencia,\n                 shape = fila)) +\n  geom_point()\n\n\n# organizar os gráficos\narrange_ggplot(p1, p2, p3,\n               ncol = 3,\n               tag_levels = list(c(\"p1\", \"p2\", \"p3\")))"
  },
  {
    "objectID": "07_datavis.html#salvar-gráficos",
    "href": "07_datavis.html#salvar-gráficos",
    "title": "8. Visualização de dados",
    "section": "\n3.8 Salvar gráficos",
    "text": "3.8 Salvar gráficos\nA função ggsave() é uma função conveniente para salvar um gráfico. O padrão é salvar a última plotagem exibida, usando o tamanho do dispositivo gráfico atual. Também é possível informar a altura (height) e circunferencia (width). Ele também adivinha o tipo de dispositivo gráfico da extensão. No seguinte exemplo, o gráfico acima é salvo no diretório de trabalho atual com o nome pontos.png, com 5 polegadas de altura e 10 de circunferencia.\n\nggsave(\"pontos.png\",\n       height = 5,\n       width = 10)"
  },
  {
    "objectID": "07_datavis.html#facet-facetas",
    "href": "07_datavis.html#facet-facetas",
    "title": "8. Visualização de dados",
    "section": "\n3.9 Facet (facetas)",
    "text": "3.9 Facet (facetas)\nMapeando os diferentes níveis de cor para diferentes cores, incluímos em um único gráfico os dados de todos osgrupos. Mas, e se nosso objetivo fosse realizar um gráfico para cada grupo? O ggplot2 tem uma poderosa ferramenta para isto: as funções facet_. Ao utilizar estas funções, o conjunto de dados é subdividido e um gráfico é construído para cada um destes subconjuntos. Vamos ver como elas podem nos ajudar em nosso problema.\n\nfac1 &lt;- \n  ggplot(df, aes(x = dap_suta,\n                 y = circunferencia,\n                 color = fila)) +\n  geom_point() +\n  facet_wrap(~ fila, ncol = 5)\nfac1\n\n\n\nUm painel para cada nível da variável grupo.\n\n\n\nNeste exemplo, um gráfico completamente diferente do anterior é gerado com apenas uma simples adição: incluímos uma nova função, facet_wrap(~ fila). Neste caso, informamos que um gráfico deveria ser realizado para cada grupo."
  },
  {
    "objectID": "07_datavis.html#theme-temas",
    "href": "07_datavis.html#theme-temas",
    "title": "8. Visualização de dados",
    "section": "\n3.10 Theme (temas)",
    "text": "3.10 Theme (temas)\nCada gráfico criado com a função ggplot() tem um tema padrão. Tema, aqui, é toda propriedade relacionada ao aspecto visual do gráfico, que não foi definida na função aes() e que pode ser modificada utilizando a função theme() (veja ?theme). O ggplot2 já conta com alguns temas personalizados para facilitar nosso trabalho. Considerando o exemplo anterior, vamos utilizar a função theme_bw() (preto e branco) e a função theme() para modificar as propriedades visuais do gráfico.\n\nfac2 &lt;- \n  ggplot(df, aes(x = dap_suta, y = circunferencia, color = fila)) +\n  geom_point() +\n  facet_wrap(~ fila) +\n  theme_light() +\n  theme(panel.grid.minor = element_blank(), # remove as linhas do corpo do gráfico\n        # sem bordas entre os painéis\n        panel.spacing = unit(0, \"cm\"),\n        # legenda abaixo do gráfico\n        legend.position = \"bottom\",\n        # modifica o texto dos eixos\n        axis.text = element_text(size = 12, colour = \"black\"),\n        # cor dos marcadores\n        axis.ticks = element_line(colour = \"black\"),\n        # tamanho dos marcadores\n        axis.ticks.length = unit(.2, \"cm\"))+\n  # título dos eixos\n  labs(x = \"Diâmetro a altura do peito (cm)\", # título do eixo x\n       y = \"Circunferência\", # título do eixo y\n       color = \"\") # título da legenda\n\narrange_ggplot(fac1, fac2,\n               ncol = 1,\n               tag_levels = list(c(\"f1\", \"f2\")))\n\n\n\nGráfico de dispersão considerando a confecção de um gráfico para cada nível de um fator(f1) e modificações na propriedades do tema de um gráfico ggplot2 (f2)\n\n\n\nOs argumentos inseridos dentro das função theme() modificaram a aparência do nosso gráfico. Inúmeros outros argumentos são disponíveis, fazendo com que os gráficos originados sejam completamente personalizáveis. Digamos que precisamos confeccionar diversos gráficos e gostaríamos de manter o mesmo tema do gráfico acima. Seria exaustivo e desinteressante informar cada vez estes argumentos para cada gráfico, não? Felizmente, outra poderosa ferramenta proporcionada pelo ggplot2 é a possibilidade de confeccionarmos nossos próprios temas. Para isto, vamos executar o seguinte comando para criar um tema personalizado (my_theme()). Este tema pode então ser aplicado como uma camada adicional a cada gráfico que confecionarmos. Para evitar a necessidade da inclusão deste tema em cada gráfico gerado, iremos definir este tema como padrão utilizando a função theme_set().\n\nmy_theme &lt;- function () {\n  theme_light() %+replace% # permite que os valores informados possam ser sobescritos\n    theme(axis.ticks.length = unit(.2, \"cm\"),\n          axis.text = element_text(size = 12, colour = \"black\"),\n          axis.title = element_text(size = 12, colour = \"black\"),\n          axis.ticks = element_line(colour = \"black\"),\n          panel.border = element_rect(colour = \"black\", fill = NA, size = 0.5),\n          panel.grid.minor =  element_blank())\n}\ntheme_set(my_theme())"
  },
  {
    "objectID": "07_datavis.html#geoms-geometria",
    "href": "07_datavis.html#geoms-geometria",
    "title": "8. Visualização de dados",
    "section": "\n3.11 Geoms (geometria)",
    "text": "3.11 Geoms (geometria)\nAs funções geom_ definem qual forma geométrica será utilizada para a visualização dos dados no gráfico. Até agora, utilizamos a função geom_point()para construir gráficos de dispersão. Basicamente, qualquer outro tipo de gráfico pode ser criado dependendo da função geom_ utilizada. Dentre as diversas disponíveis no pacote ggplot2 as funções geom_ mais utilizadas são:\n\n\ngeom_abline(): para retas definidas por um intercepto e uma inclinação;\n\ngeom_hline(): para retas horizontais definidas por um intercept y;\n\ngeom_vline(): para retas verticais definidas por um intercept x;\n\ngeom_boxplot(): para boxplots;\n\ngeom_histogram(): para histogramas de frequência;\n\ngeom_smooth(): ajusta uma função para o conjunto de dados e mostra uma banda de confiança;\n\ngeom_density(): para densidades;\n\ngeom_area(): para áreas;\n\ngeom_bar(): para barras;\n\ngeom_errorbar() para barras de erro;\n\nDeste ponto em diante, vamos confeccionar alguns exemplos utilizando algumas destas funções (ou combinações destas funções) incluindo argumentos de mapeamento de estética e temas vistos até agora.\n\n3.11.1 Linhas horizontais, verticais e diagonais\nTrês importantes geometrias são apresentadas a seguir:\n\ngeom_hline() adiciona uma linha horizontal definida por um intercepto em y\ngeom_vline() adiciona uma linha vertical definida por um intercepto em x.\ngeom_abline() adiciona uma linha diagonal definida por um intercepto e uma inclinação.\n\n\ng1 &lt;- \n  ggplot(df, aes(dap_suta, circunferencia)) +\n  geom_point()\ng1\n\n\n\n# adiciona linhas horizontais e verticais\ng2 &lt;- \n  g1 +\n  geom_hline(yintercept = mean(df$circunferencia), color = \"blue\") +\n  geom_vline(xintercept = mean(df$dap_suta), color = \"red\") +\n  geom_smooth(method = \"lm\", se = FALSE)\n\narrange_ggplot(g1, g2,\n               ncol = 1,\n               tag_levels = list(c(\"g1\", \"g2\")))\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n3.11.2 Gráficos do tipo boxplot\n\nbox1 &lt;- \n  ggplot(df, aes(fila, dap_suta)) +\n  geom_boxplot()\n\nbox2 &lt;- \n  ggplot(df, aes(fila, dap_suta)) +\n  geom_boxplot(outlier.colour = \"transparent\") +\n  geom_jitter(width = 0.1, color = \"salmon\")\n\nbox3 &lt;- \n  ggplot(df, aes(fila, dap_suta, fill = fila)) +\n  geom_boxplot(width = 0.3) + \n  labs(x = \"Grupo\",\n       y = \"dap_suta do grão (mm)\") +\n  theme(legend.position = \"bottom\")\n\narrange_ggplot((box1 + box2) / box3,\n               tag_levels = list(c(\"b1\", \"b2\", \"b3\")))\n\n\n\nGráfico do tipo boxplot combinando mapeamentos estéticos.\n\n\n\nCinco estatísticas são mostradas neste boxplot. A mediana (linha horizontal), as caixas inferior e superior (primeiro e terceiro quartil (percentis 25 e 75, respectivamente)). A linha vertical superior se estende da caixa até o maior valor, não maior que $1,5 $ (onde IQR é a amplitude interquartílica). A linha vertical inferior se estende da caixa até o menor valor, de no máximo, $1,5 $. Dados além das linhas horizontais podem ser considerados outliers.\n\n3.11.3 Gráficos do tipo barra\nNo seguinte exemplo, os dados do dap_suta do grão de café disponíveis em df são utilizados.\n\nbar1 &lt;- \n  ggplot(df, aes(x = fila, y = dap_suta)) +\n  geom_bar(stat = \"summary\", fun = \"mean\")\n\nbar2 &lt;- \n  ggplot(df, aes(x = fila, y = dap_suta, fill = fila)) +\n  stat_summary(fun = mean,\n               geom = \"bar\",\n               col = \"black\",\n               width = 0.8,\n               position = position_dodge(0.8)) + \n  stat_summary(fun.data = mean_se,\n               geom = \"errorbar\",\n               width = 0.2,\n               position = position_dodge(0.8))\n\n\narrange_ggplot(bar1, bar2,\n               widths = c(0.6, 1.2),\n               tag_levels = list(c(\"bar1\", \"bar2\")))\n\n\n\nGráfico do tipo barras, com mapeamento estético e barras de erro.\n\n\n\nA afirmação de que um gráfico ggplot2 é feito em camadas fica mais evidente aqui. No gráfico bar1, as barras representam as médias geral do dap_suta para cada grupo. No segundo gráfico, ao usar fill = fila informamos que as barras devem ser coloridas para cada nível do fator fila. A função stat_summary(), é vista pela primeira vez aqui, foi utilizada no segundo gráfico para substituir a função geom_bar(). Com isto, foi possível incluir as médias (fun = mean e geom = \"bar), bem como as barras de erro (fun.data = mean_se e geom = \"errorbar\").\n\n3.11.4 Gráficos do tipo histograma e densidade\n\nh1 &lt;- \n  ggplot(df, aes(x = circunferencia)) +\n  geom_histogram()\n\nd1 &lt;- \n  ggplot(df, aes(x = circunferencia)) +\n  geom_density()\n\narrange_ggplot(h1, d1,\n               widths = c(1, 1.4),\n               tag_levels = list(c(\"h1\", \"h2\")))\n\n\n\nGráfico do tipo histograma"
  },
  {
    "objectID": "07_datavis.html#mapas",
    "href": "07_datavis.html#mapas",
    "title": "8. Visualização de dados",
    "section": "\n3.12 Mapas",
    "text": "3.12 Mapas\n\n3.12.1 Mapa da américa do sul e Brasil\nO pacote rnaturalearth é uma excelente ferramenta para manter e facilitar a interação com os dados do mapa Natural Earth. Para produção de mapas com o ggplot2, os seguintes pacotes são necessários.\n\n#| out-width: \"100%\"\n\n\n# américa do sul\nlibrary(rnaturalearth)\nlibrary(tidyverse)\nsam &lt;-\n  ne_countries(continent = \"south america\",\n               returnclass = \"sf\",\n               scale = 50)\n\np1 &lt;- \n  ggplot() +\n  geom_sf(data = sam, fill = \"white\") +\n  theme_light() +\n  xlim(c(-90, -35))\n\n# plotar o brasil e destacar santa catarina\nbrazil &lt;- \n  ne_states(country = \"brazil\", returnclass = \"sf\") |&gt; \n  mutate(scat = ifelse(postal == \"PR\", \"PR\", \"Outros\"))\n\np2 &lt;- \n  p1 + \n  geom_sf(data = brazil, aes(fill = scat))\np2\n\n\n\n\n\n3.12.2 Mapa do Brasil e SC, com municípios\n\nlibrary(geobr)\n\n\npr &lt;- \n  read_municipality(code_muni = \"PR\",\n                    simplified = FALSE,\n                    showProgress = FALSE) |&gt; \n  mutate(Curitiba = ifelse(name_muni == \"Curitiba\",\n                          \"Curitiba\",\n                          \"Outro\"))\n\nUsing year/date 2010\n\np3 &lt;-\n  p1 + \n  geom_sf(data = brazil) +\n  geom_sf(data = pr, aes(fill = Curitiba)) +\n  xlim(c(-55, -47)) +\n  ylim(c(-28, -22)) +\n  labs(title = \"Mapa do brasil destacando o estado de SC\",\n       caption = \"Produzido com os pkgs geobr e rnaturalearth\",\n       fill = \"\") +\n  theme(legend.position = \"bottom\")\n\nScale for x is already present.\nAdding another scale for x, which will replace the existing scale.\n\np3"
  },
  {
    "objectID": "07_datavis.html#footnotes",
    "href": "07_datavis.html#footnotes",
    "title": "8. Visualização de dados",
    "section": "Footnotes",
    "text": "Footnotes\n\nWICKHAM, H. Ggplot2 : elegant graphics for data analysis: Springer, 2009.↩︎"
  }
]